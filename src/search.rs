use camino::Utf8Path;
use hash40::Hash40;
use serde::{de::Error, de::Visitor, ser::SerializeMap, Deserialize, Serialize};

struct FolderVisitor;

impl<'de> Visitor<'de> for FolderVisitor {
    type Value = Folder;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid folder structure")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        // If the path is a hex string then we can rule out it having it's own parent
        if let Ok(hash) = Hash40::from_hex_str(v) {
            return Ok(Folder {
                full_path: hash,
                name: None,
                parent: None,
            });
        }

        let full_path = Hash40::new(v);

        let path = Utf8Path::new(v);

        // We don't have to worry about any of the character casings
        // here because the Hash40::new impl handles that all for us
        let name = path.file_name().map(Hash40::new);

        let parent = path
            .parent()
            .and_then(|parent| FolderVisitor.visit_str::<E>(parent.as_str()).ok())
            .map(Box::new);

        Ok(Folder {
            full_path,
            name,
            parent,
        })
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::MapAccess<'de>,
    {
        // this deserialization is only intended for maps which have been auto-generated by tooling
        // there is no reason for any user to create this map as all of the required fields can be derived
        // from a single path

        // begin by creating all of our fields as mutable and storing them in some invalid state
        // since we can concatenate Hash40 values, we, only need the map to hold the name and the parent,
        let mut name: Option<Hash40> = None;
        let mut parent: Option<Box<Folder>> = None;

        // loop over the entries of the map and get the ones we care about
        while let Some(key) = map.next_key::<String>()? {
            match key.as_str() {
                "name" => name = Some(map.next_value()?),
                "parent" => parent = Some(map.next_value::<Folder>().map(Box::new)?),
                _ => return Err(A::Error::custom("Invalid map key encountered")),
            }
        }

        // if there is no name then we have to fail
        let Some(name) = name else {
            return Err(A::Error::custom(
                "The map structure *must* contain a name field",
            ));
        };

        // if there is no parent then we have to fail
        let Some(parent) = parent else {
            return Err(A::Error::custom(
                "The map structure *must* contain a folder field",
            ));
        };

        // create the full path out of a concatenation
        let full_path = parent.full_path.join_path(name);

        Ok(Folder {
            full_path,
            name: Some(name),
            parent: Some(parent),
        })
    }
}

/// Represents one entry using a recursive structure to navigate through parents. Used when adding new folders to the search section.
pub struct Folder {
    pub full_path: Hash40,
    pub name: Option<Hash40>,
    pub parent: Option<Box<Folder>>,
}

impl Serialize for Folder {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        if let Some(name) = self.name.as_ref() && let Some(parent) = self.parent.as_ref() {
            let mut map = serializer.serialize_map(Some(2))?;
            map.serialize_entry("name", name)?;
            map.serialize_entry("parent", parent)?;
            map.end()
        } else {
            self.full_path.serialize(serializer)
        }
    }
}

impl<'de> Deserialize<'de> for Folder {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(FolderVisitor)
    }
}

struct FileVisitor;

impl<'de> Visitor<'de> for FileVisitor {
    type Value = File;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("A valid file structure")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: Error,
    {
        // This is actually invalid here, as we need a real path with real information
        // in order to accurately add the information to the search section
        if Hash40::from_hex_str(v).is_ok() {
            return Err(E::custom(
                "File structure must either be a map or a real path",
            ));
        }

        let full_path = Hash40::new(v);

        let path = Utf8Path::new(v);

        // We don't have to worry about any of the character casings
        // here because the Hash40::new impl handles that all for us
        let Some(file_name) = path.file_name().map(Hash40::new) else {
            return Err(E::custom("The file path must have a valid file name"));
        };

        // Files must contain valid extensions so that when the game searches for the first file w/ an extension it can get picked up
        let Some(extension) = path.extension().map(Hash40::new) else {
            return Err(E::custom("The file path must have a valid extension"));
        };

        // Files must have a valid, non-root, parent that we can use to insert them into the search section with
        let Some(parent) = path.parent() else {
            return Err(E::custom("The file must have a valid parent and must not be in the root of the filesystem"));
        };

        let parent = FolderVisitor.visit_str::<E>(parent.as_str())?;

        Ok(File {
            full_path,
            file_name,
            parent,
            extension,
        })
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::MapAccess<'de>,
    {
        // this deserialization is only intended for maps which have been auto-generated by tooling
        // there is no reason for any user to create this map as all of the required fields can be derived
        // from a single path

        // begin by creating all of our fields as mutable and storing them in some invalid state
        // since we can concatenate Hash40 values, we, only need the map to hold the name and the parent,
        let mut file_name: Option<Hash40> = None;
        let mut parent: Option<Folder> = None;
        let mut extension: Option<Hash40> = None;

        // loop over the entries of the map and get the ones we care about
        while let Some(key) = map.next_key::<String>()? {
            match key.as_str() {
                "file-name" | "file_name" => file_name = Some(map.next_value()?),
                "parent" => parent = Some(map.next_value()?),
                "extension" => extension = Some(map.next_value()?),
                _ => return Err(A::Error::custom("Invalid map key encountered")),
            }
        }

        // if there is no name then we have to fail
        let Some(file_name) = file_name else {
            return Err(A::Error::custom(
                "The map structure *must* contain a name field",
            ));
        };

        // if there is no parent then we have to fail
        let Some(parent) = parent else {
            return Err(A::Error::custom(
                "The map structure *must* contain a parent field",
            ));
        };

        let Some(extension) = extension else {
            return Err(A::Error::custom(
                "The map structure *must* contain an extension field"
            ));
        };

        // create the full path out of a concatenation
        let full_path = parent.full_path.join_path(file_name);

        Ok(File {
            full_path,
            file_name,
            parent,
            extension,
        })
    }
}

/// Represents one entry using a recursive structure to naviagate through parents. Used when adding new files to any table.
pub struct File {
    pub full_path: Hash40,
    pub file_name: Hash40,
    pub parent: Folder,
    pub extension: Hash40,
}

impl<'de> Deserialize<'de> for File {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(FileVisitor)
    }
}

impl Serialize for File {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(Some(3))?;
        map.serialize_entry("file-name", &self.file_name)?;
        map.serialize_entry("parent", &self.parent)?;
        map.serialize_entry("extension", &self.extension)?;
        map.end()
    }
}

struct FileSetVisitor;

impl<'de> Visitor<'de> for FileSetVisitor {
    type Value = FileSet;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("One or more file structures")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: Error,
    {
        FileVisitor
            .visit_str::<E>(v)
            .map(|value| FileSet(vec![value]))
    }

    fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::MapAccess<'de>,
    {
        FileVisitor.visit_map(map).map(|value| FileSet(vec![value]))
    }

    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        let mut vec = vec![];
        while let Some(item) = seq.next_element()? {
            vec.push(item)
        }
        Ok(FileSet(vec))
    }
}

/// Represents a collection of new files, with a custom serializer/deserializer to make it easy for regular users to provide input.
pub struct FileSet(Vec<File>);

impl<'de> Deserialize<'de> for FileSet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(FileSetVisitor)
    }
}

impl Serialize for FileSet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        if self.0.len() == 1 {
            self.0[0].serialize(serializer)
        } else {
            self.0.serialize(serializer)
        }
    }
}
